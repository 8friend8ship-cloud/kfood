import { Author, DetectedItem, Product, RecipeEssential } from "../types";
import {
  callAnalyzeKitchenImage,
  callGenerateAvatarImage,
  callGeneratePersonaImage,
  callGenerateAuthorStory,
  callGeneratePostContent,
  callGenerateRecipeEssentials,
  callGetLocalizedIngredient
} from './firebaseService';

// NOTE: All direct Gemini API calls have been removed from this file.
// This service now acts as a passthrough to the secure, proxied backend functions
// defined in `firebaseService.ts`. This aligns with the new architecture where
// the API key is managed securely on the server.

export const analyzeKitchenImage = async (base64Image: string, productsToFind?: Product[]): Promise<DetectedItem[]> => {
  const apiKey = process.env.API_KEY; // Keep check for mock data return
  if (!apiKey || apiKey === "YOUR_API_KEY") {
    console.warn("Gemini API Key is missing. Using Firebase mock data for vision analysis.");
  }
  try {
    return await callAnalyzeKitchenImage(base64Image, productsToFind);
  } catch (error) {
    console.error("Gemini Vision Analysis via proxy failed:", error);
    return [];
  }
};

export const generateAvatarImage = async (author: Author): Promise<string> => {
  try {
    return await callGenerateAvatarImage(author);
  } catch (error) {
    console.error("Avatar generation via proxy failed:", error);
    throw new Error("Avatar generation failed.");
  }
};

export const generatePersonaImage = async (
  referenceAvatarBase64: string,
  food: string,
  setting: string,
  style: 'person' | 'food_only' = 'person'
): Promise<string> => {
  try {
    return await callGeneratePersonaImage(referenceAvatarBase64, food, setting, style);
  } catch (error) {
    console.error("Persona image generation via proxy failed:", error);
    throw new Error("No image was generated by the API.");
  }
};

export const generateAuthorStory = async (author: Author): Promise<string> => {
  try {
    return await callGenerateAuthorStory(author);
  } catch (error) {
    console.error("Failed to generate author story via proxy:", error);
    return `An error occurred while generating a story for ${author.name}.`;
  }
};

export const generatePostContent = async (
    author: Author,
    product: Product,
    isRecipeHack: boolean,
    mealContext?: string,
): Promise<{ title: string, description: string }> => {
    try {
        return await callGeneratePostContent(author, product, isRecipeHack, mealContext);
    } catch (error) {
        console.error(`Failed to generate localized content for ${author.name} via proxy:`, error);
        return {
            title: isRecipeHack ? `You HAVE to try this K-Food Hack! ðŸ¤¯` : `${author.name}'s meal: ${product.nameEn}!`,
            description: isRecipeHack ? `My new obsession: **${product.nameEn}**! It's amazing. Check the tags for ingredients!` : `Enjoying some delicious ${product.nameEn}. Perfect! Check the tags to see what I used.`
        };
    }
};

export const generateRecipeEssentials = async (base64Image: string, dishName: string): Promise<RecipeEssential[]> => {
  try {
    return await callGenerateRecipeEssentials(base64Image, dishName);
  } catch (error) {
    console.error(`Failed to generate recipe essentials for "${dishName}" via proxy:`, error);
    return [];
  }
};

export const getLocalizedIngredient = async (
  product: Product,
  author: Author
): Promise<{ localizedName: string; localizedDescription: string } | null> => {
  if (product.category !== 'ingredient' || author.country === 'Korea') {
    return null;
  }
  const isLocalizable = ['beef', 'pork', 'chicken', 'lamb', 'fish'].some(kw => product.nameEn.toLowerCase().includes(kw));
  if (!isLocalizable) {
    return null;
  }
  try {
    return await callGetLocalizedIngredient(product, author);
  } catch (error) {
    console.error(`Failed to localize ingredient "${product.nameEn}" for ${author.country} via proxy:`, error);
    return null;
  }
};